"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AirbyteSourceBase = void 0;
const lodash_1 = require("lodash");
const verror_1 = __importDefault(require("verror"));
const protocol_1 = require("../protocol");
const source_1 = require("./source");
/**
 * Airbyte Source base class providing additional boilerplate around the Check
 * and Discover commands, and the logic for processing the Source's streams. The
 * user needs to implement the spec() and checkConnection() methods and the
 * streams.
 */
class AirbyteSourceBase extends source_1.AirbyteSource {
    constructor(logger) {
        super();
        this.logger = logger;
    }
    /**
     * Source name
     */
    get name() {
        return this.constructor.name;
    }
    /**
     * Implements the Discover operation from the Airbyte Specification. See
     * https://docs.airbyte.io/architecture/airbyte-specification.
     */
    async discover(config) {
        const streams = this.streams(config).map((stream) => stream.asAirbyteStream());
        return new protocol_1.AirbyteCatalogMessage({ streams });
    }
    /**
     * Implements the Check Connection operation from the Airbyte Specification.
     * See https://docs.airbyte.io/architecture/airbyte-specification.
     */
    async check(config) {
        var _a;
        try {
            const [succeeded, error] = await this.checkConnection(config);
            if (!succeeded) {
                return new protocol_1.AirbyteConnectionStatusMessage({
                    status: protocol_1.AirbyteConnectionStatus.FAILED,
                    message: error.message,
                });
            }
        }
        catch (error) {
            return new protocol_1.AirbyteConnectionStatusMessage({
                status: protocol_1.AirbyteConnectionStatus.FAILED,
                message: (_a = error.message) !== null && _a !== void 0 ? _a : `Unknown error: ${JSON.stringify(error)}`,
            });
        }
        return new protocol_1.AirbyteConnectionStatusMessage({
            status: protocol_1.AirbyteConnectionStatus.SUCCEEDED,
        });
    }
    /**
     * Implements the Read operation from the Airbyte Specification. See
     * https://docs.airbyte.io/architecture/airbyte-specification.
     */
    async *read(config, catalog, state) {
        var _a;
        this.logger.info(`Syncing ${this.name}`);
        const connectorState = (0, lodash_1.cloneDeep)(state !== null && state !== void 0 ? state : {});
        // TODO: assert all streams exist in the connector
        // get the streams once in case the connector needs to make any queries to
        // generate them
        const streamInstances = (0, lodash_1.keyBy)(this.streams(config), (s) => s.name);
        for (const configuredStream of catalog.streams) {
            const streamName = configuredStream.stream.name;
            const streamInstance = streamInstances[streamName];
            if (!streamInstance) {
                throw new verror_1.default(`The requested stream ${streamName} was not found in the source. Available streams: ${Object.keys(streamInstances)}`);
            }
            try {
                const generator = this.readStream(streamInstance, configuredStream, connectorState);
                for await (const message of generator) {
                    yield message;
                }
            }
            catch (e) {
                this.logger.error(`Encountered an error while reading stream ${streamName}: ${(_a = e.message) !== null && _a !== void 0 ? _a : JSON.stringify(e)}`, e.stack);
                throw e;
            }
        }
        this.logger.info(`Finished syncing ${this.name}`);
    }
    async *readStream(streamInstance, configuredStream, connectorState) {
        const useIncremental = configuredStream.sync_mode === protocol_1.SyncMode.INCREMENTAL &&
            streamInstance.supportsIncremental;
        const recordGenerator = useIncremental
            ? this.readIncremental(streamInstance, configuredStream, connectorState)
            : this.readFullRefresh(streamInstance, configuredStream);
        let recordCounter = 0;
        const streamName = configuredStream.stream.name;
        const mode = useIncremental ? 'incremental' : 'full';
        this.logger.info(`Syncing ${streamName} stream in ${mode} mode`);
        for await (const record of recordGenerator) {
            if (record.type === protocol_1.AirbyteMessageType.RECORD) {
                recordCounter++;
            }
            yield record;
        }
        this.logger.info(`Finished syncing ${streamName} stream. Read ${recordCounter} records`);
    }
    async *readIncremental(streamInstance, configuredStream, connectorState) {
        var _a;
        const streamName = configuredStream.stream.name;
        let streamState = (_a = connectorState[streamName]) !== null && _a !== void 0 ? _a : {};
        if (streamState) {
            this.logger.info(`Setting initial state of ${streamName} stream to ${JSON.stringify(streamState)}`);
        }
        const checkpointInterval = streamInstance.stateCheckpointInterval;
        if (checkpointInterval < 0) {
            throw new verror_1.default(`Checkpoint interval ${checkpointInterval}of ${streamName} stream must be a positive integer`);
        }
        const slices = streamInstance.streamSlices(protocol_1.SyncMode.INCREMENTAL, configuredStream.cursor_field, streamState);
        for await (const slice of slices) {
            if (slice) {
                this.logger.info(`Started processing ${streamName} stream slice ${JSON.stringify(slice)}`);
            }
            let recordCounter = 0;
            const records = streamInstance.readRecords(protocol_1.SyncMode.INCREMENTAL, configuredStream.cursor_field, slice, streamState);
            for await (const recordData of records) {
                recordCounter++;
                yield protocol_1.AirbyteRecord.make(streamName, recordData);
                streamState = streamInstance.getUpdatedState(streamState, recordData);
                if (checkpointInterval && recordCounter % checkpointInterval === 0) {
                    yield this.checkpointState(streamName, streamState, connectorState);
                }
            }
            yield this.checkpointState(streamName, streamState, connectorState);
            if (slice) {
                this.logger.info(`Finished processing ${streamName} stream slice ${JSON.stringify(slice)}. Read ${recordCounter} records`);
            }
        }
        this.logger.info(`Last recorded state of ${streamName} stream is ${JSON.stringify(streamState)}`);
    }
    async *readFullRefresh(streamInstance, configuredStream) {
        const streamName = configuredStream.stream.name;
        const slices = streamInstance.streamSlices(protocol_1.SyncMode.FULL_REFRESH, configuredStream.cursor_field);
        for await (const slice of slices) {
            if (slice) {
                this.logger.info(`Started processing ${streamName} stream slice ${JSON.stringify(slice)}`);
            }
            let recordCounter = 0;
            const records = streamInstance.readRecords(protocol_1.SyncMode.FULL_REFRESH, configuredStream.cursor_field, slice);
            for await (const record of records) {
                recordCounter++;
                yield protocol_1.AirbyteRecord.make(configuredStream.stream.name, record);
            }
            if (slice) {
                this.logger.info(`Finished processing ${streamName} stream slice ${JSON.stringify(slice)}. Read ${recordCounter} records`);
            }
        }
    }
    checkpointState(streamName, streamState, connectorState) {
        connectorState[streamName] = streamState;
        return new protocol_1.AirbyteStateMessage({ data: connectorState });
    }
}
exports.AirbyteSourceBase = AirbyteSourceBase;
//# sourceMappingURL=source-base.js.map