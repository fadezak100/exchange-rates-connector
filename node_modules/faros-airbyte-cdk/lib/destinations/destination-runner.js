"use strict";
/* eslint-disable @typescript-eslint/no-var-requires */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AirbyteDestinationRunner = void 0;
const commander_1 = require("commander");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const errors_1 = require("../errors");
const help_1 = require("../help");
const runner_1 = require("../runner");
const utils_1 = require("../utils");
class AirbyteDestinationRunner extends runner_1.Runner {
    constructor(logger, destination) {
        super(logger);
        this.logger = logger;
        this.destination = destination;
    }
    mainCommand() {
        return new commander_1.Command()
            .name('main')
            .version('v' + utils_1.PACKAGE_VERSION)
            .addCommand(this.specCommand())
            .addCommand(this.specPrettyCommand())
            .addCommand(this.airbyteLocalCLIWizardCommand())
            .addCommand(this.checkCommand())
            .addCommand(this.writeCommand());
    }
    specCommand() {
        return new commander_1.Command()
            .command('spec')
            .description('spec command')
            .alias('s')
            .action(async () => {
            const spec = await this.destination.spec();
            // Expected output
            this.logger.write(spec);
        });
    }
    checkCommand() {
        return new commander_1.Command()
            .command('check')
            .description('check command')
            .alias('c')
            .requiredOption('--config <path to json>', 'config json')
            .action(async (opts) => {
            const config = require(path_1.default.resolve(opts.config));
            const status = await this.destination.check(config);
            // Expected output
            this.logger.write(status);
        });
    }
    writeCommand() {
        return new commander_1.Command()
            .command('write')
            .description('write command')
            .alias('w')
            .requiredOption('--config <path to json>', 'config json')
            .requiredOption('--catalog <path to json>', 'catalog json')
            .option('--dry-run', 'dry run to skip writing records to destination', false)
            .action(async (opts) => {
            const { catalog, spec, config } = await this.loadConfig(opts);
            this.logger.info(`Config: ${(0, utils_1.redactConfig)(config, spec)}`);
            this.logger.info(`Catalog: ${JSON.stringify(catalog)}`);
            try {
                process.stdin.setEncoding('utf-8');
                const iter = this.destination.write(config, catalog, process.stdin, opts.dryRun);
                for await (const message of iter) {
                    this.logger.write(message);
                }
            }
            catch (e) {
                const w = (0, errors_1.wrapApiError)(e);
                const s = JSON.stringify(w);
                this.logger.error(`Encountered an error while writing to destination: ${w} - ${s}`, w.stack);
                throw e;
            }
            finally {
                process.stdin.destroy();
            }
        });
    }
    specPrettyCommand() {
        return new commander_1.Command()
            .command('spec-pretty')
            .description('pretty spec command')
            .action(async () => {
            const spec = await this.destination.spec();
            const rows = (0, help_1.traverseObject)(spec.spec.connectionSpecification, [
                // Prefix argument names with --dst
                '--dst',
            ], 
            // Assign section = 0 to the root object's row, which
            // will be removed, so that the remaining rows are
            // numbered 1..N
            0);
            // Drop the first row since it corresponds to the root
            // (connectionSpecification) object
            rows.shift();
            console.log((0, help_1.helpTable)(rows));
        });
    }
    airbyteLocalCLIWizardCommand() {
        return new commander_1.Command()
            .command('airbyte-local-cli-wizard')
            .option('--json <path to json>', 'Output the destination configuration as JSON')
            .description('Run a wizard command to prepare arguments for Airbyte Local CLI')
            .action(async (opts) => {
            const spec = await this.destination.spec();
            const rows = (0, help_1.traverseObject)(spec.spec.connectionSpecification, opts.json
                ? []
                : [
                    // Prefix argument names with --dst
                    '--dst',
                ], 
            // Assign section = 0 to the root object's row
            0);
            if (opts.json) {
                fs_1.default.writeFileSync(opts.json, await (0, help_1.buildJson)(rows));
            }
            else {
                console.log('\n\nUse the arguments below when running this destination' +
                    ' with Airbyte Local CLI (https://github.com/faros-ai/airbyte-local-cli):' +
                    `\n\n${await (0, help_1.buildArgs)(rows)}`);
            }
        });
    }
    async loadConfig(opts) {
        try {
            const catalog = require(path_1.default.resolve(opts.catalog));
            const spec = await this.destination.spec();
            const config = (0, utils_1.withDefaults)(require(path_1.default.resolve(opts.config)), spec);
            return { catalog, spec, config };
        }
        catch (e) {
            const w = (0, errors_1.wrapApiError)(e);
            const s = JSON.stringify(w);
            this.logger.error(`Encountered an error while loading configuration: ${w} - ${s}`, w.stack);
            throw e;
        }
    }
}
exports.AirbyteDestinationRunner = AirbyteDestinationRunner;
//# sourceMappingURL=destination-runner.js.map