"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildArgs = exports.buildJson = exports.helpTable = exports.traverseObject = void 0;
const assert_1 = require("assert");
const lodash_1 = __importDefault(require("lodash"));
const lodash_2 = require("lodash");
const table_1 = require("table");
const verror_1 = require("verror");
const prompts_1 = require("./prompts");
function visitLeaf(o, curPath, section, required = false) {
    var _a;
    const title = o.title || curPath.slice(-1)[0].split('_').map(lodash_2.upperFirst).join(' ');
    const leaf = {
        title,
        path: curPath.join('.'),
        section,
        required,
        description: o.description,
        airbyte_secret: o.airbyte_secret,
        default: o.default,
        constValue: o.const,
        multiline: o.multiline,
        examples: o.examples,
        type: o.type,
        items_type: (_a = o.items) === null || _a === void 0 ? void 0 : _a.type,
    };
    return leaf;
}
function traverseObject(startObject, startPath, section = 1, required = false) {
    const result = [];
    // Queue of objects to process in BFS
    const process = [
        [startObject, startPath, section, required],
    ];
    let newIdx = section + 1;
    while (process.length > 0) {
        const [curObject, curPath, idx, req] = process.shift();
        if (curObject['type'] !== 'object') {
            result.push(visitLeaf(curObject, curPath, idx, req));
            continue;
        }
        (0, assert_1.ok)(curObject.properties || curObject.oneOf);
        (0, assert_1.ok)(curObject.properties === undefined || curObject.oneOf === undefined);
        (0, assert_1.ok)(curObject.title);
        if (curObject.properties) {
            const children = Object.keys(curObject.properties).length;
            if (!children) {
                result.push({
                    title: curObject.title,
                    path: curPath.join('.'),
                    section: idx,
                    description: 'Skip this section',
                    required: false,
                    type: 'empty_object',
                    examples: [],
                });
                continue;
            }
            result.push({
                title: curObject.title,
                path: curPath.join('.'),
                section: idx,
                children: lodash_1.default.range(newIdx, newIdx + children),
                oneOf: false,
                description: `Please configure argument${children > 1 ? 's' : ''} ${lodash_1.default.range(newIdx, newIdx + children).join()} as needed`,
                required: req,
                type: 'object',
                examples: [],
            });
            const requiredProperties = curObject.required || [];
            const cmp = function compareFn(a, b) {
                const aOrder = curObject.properties[a]['order'];
                const bOrder = curObject.properties[b]['order'];
                // Properties with 'order' should appear before than
                // those without.
                if (aOrder !== undefined && bOrder === undefined)
                    return -1;
                if (aOrder === undefined && bOrder !== undefined)
                    return 1;
                // At this point they're both undefined or both
                // with order. Only return if they are not tied.
                if (aOrder !== bOrder)
                    return aOrder - bOrder;
                // Break the tie by comparing the property names.
                return a.localeCompare(b);
            };
            for (const propertyName of Object.keys(curObject.properties).sort(cmp)) {
                process.push([
                    curObject.properties[propertyName],
                    curPath.concat(propertyName),
                    newIdx++,
                    requiredProperties.includes(propertyName),
                ]);
            }
        }
        else {
            const children = curObject.oneOf.length;
            (0, assert_1.ok)(children > 0);
            result.push({
                title: curObject.title,
                path: curPath.join('.'),
                section: idx,
                children: lodash_1.default.range(newIdx, newIdx + children),
                oneOf: true,
                description: children > 1
                    ? `Please select and configure a single argument from ${lodash_1.default.range(newIdx, newIdx + children).join()}`
                    : `Please configure argument ${newIdx}`,
                required: req,
                type: 'object',
                examples: [],
            });
            for (const choice of curObject.oneOf) {
                process.push([choice, curPath, newIdx++, false]);
            }
        }
    }
    return result;
}
exports.traverseObject = traverseObject;
function helpTable(rows) {
    var _a;
    const data = [
        [
            'Section ID',
            'Title',
            'Argument',
            'Description',
            'Required',
            'Constant',
            'Default',
            'Examples',
        ],
    ];
    const config = {
        columns: {
            1: { width: 15, wrapWord: true },
            2: { width: 15, wrapWord: true },
            3: { width: 30, wrapWord: true },
            7: { width: 20, wrapWord: true },
        },
    };
    for (const row of rows) {
        data.push([
            row.section,
            row.title,
            row.path,
            row.description || '',
            row.required ? 'Yes' : 'No',
            row.constValue || '',
            (_a = row.default) !== null && _a !== void 0 ? _a : '',
            row.examples ? row.examples.join('\n') : '',
        ]);
    }
    return (0, table_1.table)(data, config);
}
exports.helpTable = helpTable;
async function promptOneOf(row, sections) {
    const choices = [];
    if (!row.required) {
        choices.push({
            message: 'Skip this section',
            value: 'Skipped.',
        });
    }
    for (const child of row.children) {
        choices.push({ message: sections.get(child).title, value: child });
    }
    const choice = await (0, prompts_1.runSelect)({
        name: 'oneOf',
        message: row.title,
        choices,
    });
    if (choice === 'Skipped.') {
        return undefined;
    }
    return +choice;
}
async function promptValue(row) {
    var _a;
    const type = (_a = row.items_type) !== null && _a !== void 0 ? _a : row.type;
    (0, assert_1.ok)(type);
    const message = row.description
        ? `${row.title}: ${row.description}`
        : row.title;
    switch (type) {
        case 'boolean':
            return await (0, prompts_1.runBooleanPrompt)({ message });
        case 'integer':
            return await (0, prompts_1.runNumberPrompt)({ message });
        case 'string':
            return await (0, prompts_1.runStringPrompt)({ message });
    }
    throw new verror_1.VError(`Unexpected type: ${type}`);
}
function choiceAsType(row, choice) {
    var _a;
    const type = (_a = row.items_type) !== null && _a !== void 0 ? _a : row.type;
    (0, assert_1.ok)(type);
    switch (type) {
        case 'boolean':
            return choice === 'true';
        case 'integer':
            return +choice;
        case 'string':
            return choice;
    }
    throw new verror_1.VError(`Unexpected type: ${type}`);
}
function formatArg(row, choice) {
    let formattedChoice = typeof choice === 'string' ? `"${choice}"` : choice;
    if (row.type === 'array') {
        formattedChoice = `'[${formattedChoice}]'`;
    }
    return `${row.path} ${formattedChoice}`;
}
async function promptLeaf(row) {
    var _a;
    if (row.type === 'empty_object') {
        return undefined;
    }
    const choices = [];
    if (row.constValue !== undefined) {
        return row.constValue;
    }
    if (!row.required) {
        choices.push({
            message: 'Skip this section',
            value: 'Skipped.',
        });
    }
    if (row.default !== undefined) {
        choices.push({
            message: `Use default (${row.default})`,
            value: 'Used default.',
        });
    }
    if ((_a = row.examples) === null || _a === void 0 ? void 0 : _a.length) {
        let idx = 0;
        for (const example of row.examples) {
            idx++;
            choices.push({ message: `example ${idx} (${example})`, value: example });
        }
    }
    let choice = ' ';
    if (choices.length) {
        choices.push({
            message: 'Enter your own value',
            value: ' ',
        });
        const message = row.description
            ? `${row.title}: ${row.description}`
            : row.title;
        choice = await (0, prompts_1.runSelect)({
            name: 'leaf',
            message,
            choices,
        });
    }
    switch (choice) {
        case 'Skipped.':
            return undefined;
        case 'Used default.':
            return row.default;
        case ' ':
            return await promptValue(row);
        default:
            return choiceAsType(row, choice);
    }
}
async function buildJson(rows) {
    const result = {};
    await acceptUserInput(rows, (row, choice) => lodash_1.default.set(result, row.path, row.type === 'array' ? [choice] : choice));
    return JSON.stringify(result);
}
exports.buildJson = buildJson;
async function buildArgs(rows) {
    const result = [];
    await acceptUserInput(rows, (row, choice) => result.push(formatArg(row, choice)));
    return result.join(' \\\n');
}
exports.buildArgs = buildArgs;
async function acceptUserInput(rows, action) {
    var _a;
    const sections = new Map(rows.map((row) => [row.section, row]));
    // Stack of sections to process in DFS
    const process = [0];
    const processed = [];
    while (process.length) {
        const section = process.pop();
        processed.push(section);
        const row = sections.get(section);
        if ((_a = row.children) === null || _a === void 0 ? void 0 : _a.length) {
            if (row.oneOf) {
                const choice = await promptOneOf(row, sections);
                if (choice) {
                    process.push(choice);
                }
            }
            else {
                for (let idx = row.children.length - 1; idx >= 0; idx--) {
                    process.push(row.children[idx]);
                }
            }
        }
        else {
            const choice = await promptLeaf(row);
            if (choice !== undefined) {
                action(row, choice);
            }
        }
    }
}
//# sourceMappingURL=help.js.map