"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AirbyteStreamBase = void 0;
const lodash_1 = require("lodash");
const verror_1 = __importDefault(require("verror"));
const protocol_1 = require("../../protocol");
/**
 * Base abstract class for an Airbyte Stream. Makes no assumption of the
 * Stream's underlying transport protocol.
 */
class AirbyteStreamBase {
    constructor(logger) {
        this.logger = logger;
    }
    /**
     * @returns Stream name. By default this is the implementing class name, but
     * it can be overridden as needed.
     */
    get name() {
        return (0, lodash_1.snakeCase)(this.constructor.name);
    }
    asAirbyteStream() {
        var _a;
        const stream = {
            name: this.name,
            json_schema: this.getJsonSchema(),
            supported_sync_modes: [protocol_1.SyncMode.FULL_REFRESH],
        };
        if (this.supportsIncremental) {
            stream.source_defined_cursor = this.sourceDefinedCursor;
            (_a = stream.supported_sync_modes) === null || _a === void 0 ? void 0 : _a.push(protocol_1.SyncMode.INCREMENTAL);
            stream.default_cursor_field = this.wrappedCursorField();
        }
        const keys = AirbyteStreamBase.wrappedPrimaryKey(this.primaryKey);
        if (keys && keys.length > 0) {
            stream.source_defined_primary_key = keys;
        }
        return stream;
    }
    /**
     * @returns True if this stream supports incrementally reading data
     */
    get supportsIncremental() {
        return this.wrappedCursorField().length > 0;
    }
    wrappedCursorField() {
        if (!this.cursorField) {
            throw new verror_1.default('Cursor field cannot be null, undefined, or empty string');
        }
        return typeof this.cursorField === 'string'
            ? [this.cursorField]
            : this.cursorField;
    }
    /**
     * Override to return the default cursor field used by this stream e.g: an API
     * entity might always use created_at as the cursor field.
     * @returns The name of the field used as a cursor. If the cursor is nested,
     * return an array consisting of the path to the cursor.
     */
    get cursorField() {
        return [];
    }
    /**
     * @returns False if the cursor can be configured by the user.
     */
    get sourceDefinedCursor() {
        return true;
    }
    /* eslint-disable @typescript-eslint/no-unused-vars */
    /**
     * Override to define the slices for this stream. See the stream slicing
     * section of the docs for more information.
     */
    async *streamSlices(syncMode, cursorField, streamState) {
        yield undefined;
    }
    /**
     * Decides how often to checkpoint state (i.e: emit a STATE message). E.g: if
     * this returns a value of 100, then state is persisted after reading 100
     * records, then 200, 300, etc.. A good default value is 1000 although your
     * mileage may vary depending on the underlying data source.
     *
     * Checkpointing a stream avoids re-reading records in the case a sync is
     * failed or cancelled.
     *
     * @returns None if state should not be checkpointed e.g: because records
     * returned from the underlying data source are not returned in ascending
     * order with respect to the cursor field. This can happen if the source does
     * not support reading records in ascending order of created_at date (or
     * whatever the cursor is).  In those cases, state must only be saved once the
     * full stream has been read.
     */
    get stateCheckpointInterval() {
        return undefined;
    }
    /**
     * Override to extract state from the latest record. Needed to implement
     * incremental sync.
     *
     * Inspects the latest record extracted from the data source and the current
     * state object and return an updated state object.
     *
     * For example: if the state object is based on created_at timestamp, and the
     * current state is {'created_at': 10}, and the latest_record is {'name':
     * 'octavia', 'created_at': 20 } then this method would return {'created_at':
     * 20} to indicate state should be updated to this object.
     *
     * @param currentStreamState The stream's current state object
     * @param latestRecord The latest record extracted from the stream
     * @returns An updated state object
     */
    getUpdatedState(currentStreamState, latestRecord) {
        return {};
    }
    /* eslint-enable @typescript-eslint/no-unused-vars */
    /**
     * @returns wrap the primary_key property in a list of list of strings
     * required by the Airbyte Stream object.
     */
    static wrappedPrimaryKey(keys) {
        if (!keys) {
            return undefined;
        }
        if (typeof keys === 'string') {
            return [[keys]];
        }
        else {
            const wrappedKeys = [];
            for (const component of keys) {
                wrappedKeys.push(typeof component === 'string' ? [component] : component);
            }
        }
    }
}
exports.AirbyteStreamBase = AirbyteStreamBase;
//# sourceMappingURL=stream-base.js.map