"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.base64Encode = exports.toDate = exports.withDefaults = exports.redactConfig = exports.PACKAGE_VERSION = exports.PACKAGE_ROOT = void 0;
const fast_redact_1 = __importDefault(require("fast-redact"));
const fs_1 = __importDefault(require("fs"));
const json_schema_traverse_1 = __importDefault(require("json-schema-traverse"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
exports.PACKAGE_ROOT = path_1.default.join(__dirname, '..');
const packageInfo = JSON.parse(fs_1.default.readFileSync(path_1.default.join(exports.PACKAGE_ROOT, 'package.json'), 'utf8'));
exports.PACKAGE_VERSION = packageInfo.version;
/** Redact config of all secret values based on the provided specification */
function redactConfig(config, spec) {
    var _a;
    const paths = [];
    (0, json_schema_traverse_1.default)((_a = spec.spec.connectionSpecification) !== null && _a !== void 0 ? _a : {}, {
        cb: (schema, pointer) => {
            if (schema.airbyte_secret) {
                paths.push(toPath(pointer));
            }
        },
    });
    const redact = (0, fast_redact_1.default)({ paths, censor: 'REDACTED' });
    return `${redact(config)}`;
}
exports.redactConfig = redactConfig;
function toPath(pointer) {
    return pointer
        .replace(/\/oneOf\/\d+/g, '')
        .split('/properties/')
        .filter((s) => s)
        .join('.');
}
/**
 * Sets all undefined values with defaults from spec to their default value.
 * The changes are made on a copy of the input.
 * */
function withDefaults(config, spec) {
    var _a;
    const defaultsByPath = new Map();
    (0, json_schema_traverse_1.default)((_a = spec.spec.connectionSpecification) !== null && _a !== void 0 ? _a : {}, {
        cb: (schema, pointer) => {
            if (schema.default) {
                defaultsByPath.set(toPath(pointer), schema.default);
            }
        },
    });
    // create a copy of input and apply defaults
    const result = lodash_1.default.cloneDeep(config);
    for (const [path, defaultValue] of defaultsByPath) {
        if (lodash_1.default.get(result, path) === undefined) {
            lodash_1.default.set(result, path, defaultValue);
        }
    }
    return result;
}
exports.withDefaults = withDefaults;
/** Convert a value to Date */
function toDate(val) {
    if (typeof val === 'number') {
        return new Date(val);
    }
    if (!val) {
        return undefined;
    }
    return new Date(val);
}
exports.toDate = toDate;
function base64Encode(str) {
    return Buffer.from(str, 'binary').toString('base64');
}
exports.base64Encode = base64Encode;
//# sourceMappingURL=utils.js.map