"use strict";
/* eslint-disable @typescript-eslint/no-var-requires */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AirbyteSourceRunner = void 0;
const commander_1 = require("commander");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const errors_1 = require("../errors");
const help_1 = require("../help");
const runner_1 = require("../runner");
const utils_1 = require("../utils");
class AirbyteSourceRunner extends runner_1.Runner {
    constructor(logger, source) {
        super(logger);
        this.logger = logger;
        this.source = source;
    }
    mainCommand() {
        return new commander_1.Command()
            .name('main')
            .version('v' + utils_1.PACKAGE_VERSION)
            .addCommand(this.specCommand())
            .addCommand(this.specPrettyCommand())
            .addCommand(this.airbyteLocalCLIWizardCommand())
            .addCommand(this.checkCommand())
            .addCommand(this.discoverCommand())
            .addCommand(this.readCommand());
    }
    specCommand() {
        return new commander_1.Command()
            .command('spec')
            .description('spec command')
            .alias('s')
            .action(async () => {
            const spec = await this.source.spec();
            // Expected output
            this.logger.write(spec);
        });
    }
    checkCommand() {
        return new commander_1.Command()
            .command('check')
            .description('check command')
            .alias('c')
            .requiredOption('--config <path to json>', 'config json')
            .action(async (opts) => {
            const config = require(path_1.default.resolve(opts.config));
            const status = await this.source.check(config);
            // Expected output
            this.logger.write(status);
        });
    }
    discoverCommand() {
        return new commander_1.Command()
            .command('discover')
            .description('discover command')
            .alias('d')
            .requiredOption('--config <path to json>', 'config json')
            .action(async (opts) => {
            const config = require(path_1.default.resolve(opts.config));
            const catalog = await this.source.discover(config);
            // Expected output
            this.logger.write(catalog);
        });
    }
    readCommand() {
        return new commander_1.Command()
            .command('read')
            .description('read command')
            .alias('r')
            .requiredOption('--config <path to json>', 'config json')
            .requiredOption('--catalog <path to json>', 'catalog json')
            .option('--state <path to json>', 'state json')
            .action(async (opts) => {
            const config = require(path_1.default.resolve(opts.config));
            const catalog = require(path_1.default.resolve(opts.catalog));
            const spec = await this.source.spec();
            this.logger.info(`Config: ${(0, utils_1.redactConfig)(config, spec)}`);
            this.logger.info(`Catalog: ${JSON.stringify(catalog)}`);
            let state = undefined;
            if (opts.state) {
                state = require(path_1.default.resolve(opts.state));
                this.logger.info(`State: ${JSON.stringify(state)}`);
            }
            try {
                const iter = this.source.read(config, catalog, state);
                for await (const message of iter) {
                    this.logger.write(message);
                }
            }
            catch (e) {
                const w = (0, errors_1.wrapApiError)(e);
                const s = JSON.stringify(w);
                this.logger.error(`Encountered an error while reading from source: ${w} - ${s}`, w.stack);
                throw e;
            }
        });
    }
    specPrettyCommand() {
        return new commander_1.Command()
            .command('spec-pretty')
            .description('pretty spec command')
            .action(async () => {
            const spec = await this.source.spec();
            const rows = (0, help_1.traverseObject)(spec.spec.connectionSpecification, [
                // Prefix argument names with --src
                '--src',
            ], 
            // Assign section = 0 to the root object's row, which
            // will be removed, so that the remaining rows are
            // numbered 1..N
            0);
            // Drop the first row since it corresponds to the root
            // (connectionSpecification) object
            rows.shift();
            console.log((0, help_1.helpTable)(rows));
        });
    }
    airbyteLocalCLIWizardCommand() {
        return new commander_1.Command()
            .command('airbyte-local-cli-wizard')
            .option('--json <path to json>', 'Output the source configuration as JSON')
            .description('Run a wizard command to prepare arguments for Airbyte Local CLI')
            .action(async (opts) => {
            const spec = await this.source.spec();
            const rows = (0, help_1.traverseObject)(spec.spec.connectionSpecification, opts.json
                ? []
                : [
                    // Prefix argument names with --src
                    '--src',
                ], 
            // Assign section = 0 to the root object's row
            0);
            if (opts.json) {
                fs_1.default.writeFileSync(opts.json, await (0, help_1.buildJson)(rows));
            }
            else {
                console.log('\n\nUse the arguments below when running this source' +
                    ' with Airbyte Local CLI (https://github.com/faros-ai/airbyte-local-cli):' +
                    `\n\n${await (0, help_1.buildArgs)(rows)}`);
            }
        });
    }
}
exports.AirbyteSourceRunner = AirbyteSourceRunner;
//# sourceMappingURL=source-runner.js.map