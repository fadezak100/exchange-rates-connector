"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AirbyteStateMessage = exports.AirbyteSpec = exports.AirbyteTrace = exports.AirbyteRecord = exports.AirbyteRawData = exports.AirbyteRawEmittedAt = exports.AirbyteRawABId = exports.AirbyteRawStreamPrefix = exports.AirbyteLog = exports.AirbyteConnectionStatusMessage = exports.AirbyteCatalogMessage = exports.DestinationSyncMode = exports.SyncMode = exports.parseAirbyteMessage = exports.AirbyteTraceFailureType = exports.AirbyteConnectionStatus = exports.AirbyteMessageType = exports.AirbyteLogLevelOrder = exports.AirbyteLogLevel = void 0;
const verror_1 = require("verror");
const errors_1 = require("./errors");
var AirbyteLogLevel;
(function (AirbyteLogLevel) {
    AirbyteLogLevel["FATAL"] = "FATAL";
    AirbyteLogLevel["ERROR"] = "ERROR";
    AirbyteLogLevel["WARN"] = "WARN";
    AirbyteLogLevel["INFO"] = "INFO";
    AirbyteLogLevel["DEBUG"] = "DEBUG";
    AirbyteLogLevel["TRACE"] = "TRACE";
})(AirbyteLogLevel = exports.AirbyteLogLevel || (exports.AirbyteLogLevel = {}));
function AirbyteLogLevelOrder(level) {
    switch (level) {
        case AirbyteLogLevel.FATAL:
            return 60;
        case AirbyteLogLevel.ERROR:
            return 50;
        case AirbyteLogLevel.WARN:
            return 40;
        case AirbyteLogLevel.INFO:
            return 30;
        case AirbyteLogLevel.DEBUG:
            return 20;
        case AirbyteLogLevel.TRACE:
            return 10;
    }
}
exports.AirbyteLogLevelOrder = AirbyteLogLevelOrder;
var AirbyteMessageType;
(function (AirbyteMessageType) {
    AirbyteMessageType["CATALOG"] = "CATALOG";
    AirbyteMessageType["CONNECTION_STATUS"] = "CONNECTION_STATUS";
    AirbyteMessageType["LOG"] = "LOG";
    AirbyteMessageType["RECORD"] = "RECORD";
    AirbyteMessageType["SPEC"] = "SPEC";
    AirbyteMessageType["STATE"] = "STATE";
    AirbyteMessageType["TRACE"] = "TRACE";
})(AirbyteMessageType = exports.AirbyteMessageType || (exports.AirbyteMessageType = {}));
var AirbyteConnectionStatus;
(function (AirbyteConnectionStatus) {
    AirbyteConnectionStatus["SUCCEEDED"] = "SUCCEEDED";
    AirbyteConnectionStatus["FAILED"] = "FAILED";
})(AirbyteConnectionStatus = exports.AirbyteConnectionStatus || (exports.AirbyteConnectionStatus = {}));
var AirbyteTraceFailureType;
(function (AirbyteTraceFailureType) {
    AirbyteTraceFailureType["SYSTEM_ERROR"] = "system_error";
    AirbyteTraceFailureType["CONFIG_ERROR"] = "config_error";
})(AirbyteTraceFailureType = exports.AirbyteTraceFailureType || (exports.AirbyteTraceFailureType = {}));
function parseAirbyteMessage(s) {
    try {
        const res = JSON.parse(s);
        if (!res.type) {
            throw new verror_1.VError(`Message type is not set`);
        }
        switch (res.type) {
            case AirbyteMessageType.RECORD:
                return new AirbyteRecord(res.record);
            case AirbyteMessageType.CATALOG:
            case AirbyteMessageType.CONNECTION_STATUS:
            case AirbyteMessageType.LOG:
            case AirbyteMessageType.SPEC:
            case AirbyteMessageType.STATE:
            case AirbyteMessageType.TRACE:
                return res;
            default:
                throw new verror_1.VError(`Unsupported message type ${res.type}`);
        }
    }
    catch (e) {
        throw new verror_1.VError(e, `Invalid Airbyte message: ${s}`);
    }
}
exports.parseAirbyteMessage = parseAirbyteMessage;
var SyncMode;
(function (SyncMode) {
    SyncMode["FULL_REFRESH"] = "full_refresh";
    SyncMode["INCREMENTAL"] = "incremental";
})(SyncMode = exports.SyncMode || (exports.SyncMode = {}));
var DestinationSyncMode;
(function (DestinationSyncMode) {
    DestinationSyncMode["APPEND"] = "append";
    DestinationSyncMode["OVERWRITE"] = "overwrite";
    DestinationSyncMode["APPEND_DEDUP"] = "append_dedup";
})(DestinationSyncMode = exports.DestinationSyncMode || (exports.DestinationSyncMode = {}));
class AirbyteCatalogMessage {
    constructor(catalog) {
        this.catalog = catalog;
        this.type = AirbyteMessageType.CATALOG;
    }
}
exports.AirbyteCatalogMessage = AirbyteCatalogMessage;
class AirbyteConnectionStatusMessage {
    constructor(connectionStatus) {
        this.connectionStatus = connectionStatus;
        this.type = AirbyteMessageType.CONNECTION_STATUS;
    }
}
exports.AirbyteConnectionStatusMessage = AirbyteConnectionStatusMessage;
class AirbyteLog {
    constructor(log) {
        this.log = log;
        this.type = AirbyteMessageType.LOG;
    }
    static make(level, message, stack_trace) {
        return new AirbyteLog({ level, message, stack_trace });
    }
}
exports.AirbyteLog = AirbyteLog;
exports.AirbyteRawStreamPrefix = '_airbyte_raw_';
exports.AirbyteRawABId = '_airbyte_ab_id';
exports.AirbyteRawEmittedAt = '_airbyte_emitted_at';
exports.AirbyteRawData = '_airbyte_data';
class AirbyteRecord {
    constructor(record) {
        this.record = record;
        this.type = AirbyteMessageType.RECORD;
    }
    isRaw() {
        const stream = this.record.stream;
        return stream && stream.startsWith(exports.AirbyteRawStreamPrefix);
    }
    unpackRaw() {
        if (this.isRaw()) {
            return new AirbyteRecord({
                stream: this.record.stream.slice(exports.AirbyteRawStreamPrefix.length),
                emitted_at: new Date(this.record.data[exports.AirbyteRawEmittedAt]).getTime(),
                data: JSON.parse(this.record.data[exports.AirbyteRawData]),
            });
        }
        return this;
    }
    static make(stream, data, namespace) {
        return new AirbyteRecord({
            stream,
            namespace,
            emitted_at: Date.now(),
            data,
        });
    }
}
exports.AirbyteRecord = AirbyteRecord;
class AirbyteTrace {
    constructor(trace) {
        this.trace = trace;
        this.type = AirbyteMessageType.TRACE;
    }
    static make(err, failure_type) {
        const wrapped = (0, errors_1.wrapApiError)(err);
        return new AirbyteTrace({
            type: 'ERROR',
            emitted_at: Date.now(),
            error: {
                message: wrapped.message,
                stack_trace: wrapped.stack,
                internal_message: wrapped.name,
                failure_type,
                ...wrapped,
            },
        });
    }
}
exports.AirbyteTrace = AirbyteTrace;
class AirbyteSpec {
    constructor(spec) {
        this.spec = spec;
        this.type = AirbyteMessageType.SPEC;
    }
}
exports.AirbyteSpec = AirbyteSpec;
class AirbyteStateMessage {
    constructor(state) {
        this.state = state;
        this.type = AirbyteMessageType.STATE;
    }
}
exports.AirbyteStateMessage = AirbyteStateMessage;
//# sourceMappingURL=protocol.js.map